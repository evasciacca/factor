{% extends "facetselfcal_pipeline.parset" %}
{% block selfcal_steps %} {% if not preapply_phase_cal %} average0, {% endif %} create_compressed_mapfile0, sort_average0_into_Groups, sort_average0_into_Groups_maps, concat_average0_data, create_compressed_mapfile01, premask_selfcal, wsclean_image02, regroup_concat_data_map, make_fast_phase_h5parm_map, {% if peel_skymodel is not none %} create_peel_skymodel_map, make_peel_sourcedb, expand_peel_sourcedb_map, {% else %} group_skymodel0, make_sourcedb0, expand_sourcedb0_map, {% endif %} remove_h5parms1, solve_phaseonly1, {% if selfcal_local_dir is not none %} make_apply_mapfile, {% endif %} apply_phaseonly1, create_compressed_mapfile1, wsclean_image12, group_skymodel1, make_sourcedb1, expand_sourcedb1_map, remove_h5parms2, solve_phaseonly2, apply_phaseonly2, loop_phasecal, make_slow_gain_h5parm_map, remove_h5parms12, solve_ampphase12, create_compressed_mapfile_slow, create_combined_slow_output_map, match_host_slow, combine_slow_gains1, smooth_amp1, expand_smoothed_amp1_h5parm_map, apply_amp1, create_compressed_mapfile3, wsclean_image32, loop_ampcal, {% endblock selfcal_steps %}

{% block selfcal_parameters %}
########## start of first round of selfcal (20" resolution)
########## start of first round of selfcal

# apply dir-independent calibration and average, length = nfiles
# this step must be done band-by-band, as each band has its own parmdb.
# if we preapply solutions, we don't need to do this step as we already have
# averaged MSs from the shift_cal_dir_indep step
# Compress both data and weights
{% if not preapply_phase_cal %}
average0.control.type                                 = dppp
average0.control.mapfiles_in                          = [shift_cal.output.mapfile]
average0.control.inputkeys                            = [msin,parmdb]
average0.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
average0.argument.msin.datacolumn                     = DATA
average0.argument.msout.overwrite                     = True
average0.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average0.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average0.argument.steps                               = [avg]
average0.argument.avg.type                            = squash
average0.argument.avg.freqstep                        = 1
average0.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
average0.argument.msout.storagemanager                = "Dysco"
average0.argument.msout.storagemanager.databitrate    = 16
average0.argument.msout.storagemanager.weightbitrate  = 12
average0.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average0.argument.msout.storagemanager.disttruncation = 1.5
average0.argument.msout.storagemanager.normalization  = "AF"
{% endif %}
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile0.control.kind        = plugin
create_compressed_mapfile0.control.type        = compressMapfile
{% if preapply_phase_cal %}
create_compressed_mapfile0.control.mapfile_in  = shift_cal_dir_indep.output.mapfile
{% else %}
create_compressed_mapfile0.control.mapfile_in  = average0.output.mapfile
{% endif %}
create_compressed_mapfile0.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile0.control.filename    = concat_average0_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes
sort_average0_into_Groups.control.type           = sort_times_into_freqGroups
sort_average0_into_Groups.argument.flags         = [create_compressed_mapfile0.output.mapfile]
sort_average0_into_Groups.argument.filename      = sorted_average0_groups.mapfile
sort_average0_into_Groups.argument.mapfile_dir   = input.output.mapfile_dir
sort_average0_into_Groups.argument.hosts         = {{ hosts }}
sort_average0_into_Groups.argument.stepname      = sort_average0_into_Groups
sort_average0_into_Groups.argument.enforce_numSB = False
sort_average0_into_Groups.argument.nband_pad     = {{ nband_pad_selfcal }}

# convert the output of sort_average0_into_Groups into usable mapfiles, len = 1 / ntimes
sort_average0_into_Groups_maps.control.kind             = plugin
sort_average0_into_Groups_maps.control.type             = mapfilenamesFromMapfiles
sort_average0_into_Groups_maps.control.mapfile_groupmap = sort_average0_into_Groups.output.groupmapfile.mapfile
sort_average0_into_Groups_maps.control.mapfile_filesmap = sort_average0_into_Groups.output.mapfile.mapfile

# concat averaged data in frequency, length = ntimes
# Note, this step is done to ensure that we get WSClean channel images that match
# the datasets used for selfcal so that predict will work properly
# Compress both data and weights
concat_average0_data.control.type                                 = dppp
concat_average0_data.control.mapfile_out                          = sort_average0_into_Groups_maps.output.groupmap
concat_average0_data.control.mapfile_in                           = sort_average0_into_Groups_maps.output.filesmap
concat_average0_data.control.inputkey                             = msin
concat_average0_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_average0_data.argument.msin.datacolumn                     = DATA
concat_average0_data.argument.msin.missingdata                    = True
concat_average0_data.argument.msin.orderms                        = False
concat_average0_data.argument.msout.overwrite                     = True
concat_average0_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_average0_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_average0_data.argument.steps                               = []
{% if use_compression %}
concat_average0_data.argument.msout.storagemanager                = "Dysco"
concat_average0_data.argument.msout.storagemanager.databitrate    = 16
concat_average0_data.argument.msout.storagemanager.weightbitrate  = 12
concat_average0_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_average0_data.argument.msout.storagemanager.disttruncation = 1.5
concat_average0_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile for concatenated averaged data MSs, length = 1
create_compressed_mapfile01.control.kind        = plugin
create_compressed_mapfile01.control.type        = compressMapfile
create_compressed_mapfile01.control.mapfile_in  = concat_average0_data.output.mapfile
create_compressed_mapfile01.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile01.control.filename    = image0_input.mapfile

# make a mask using user-supplied region (if any), length = 1
premask_selfcal.control.type                   = make_clean_mask
premask_selfcal.control.mapfile_in             = create_compressed_mapfile01.output.mapfile
premask_selfcal.control.inputkey               = imagefile
premask_selfcal.control.outputkey              = maskfile
premask_selfcal.argument.flags                 = [imagefile,maskfile]
premask_selfcal.argument.img_format            = fits
premask_selfcal.argument.pad_to_size           = {{ cal_imsize }}
premask_selfcal.argument.skip_source_detection = True
premask_selfcal.argument.vertices_file         = {{ vertices_file }}
premask_selfcal.argument.reference_ra_deg      = {{ ra }}
premask_selfcal.argument.reference_dec_deg     = {{ dec }}
premask_selfcal.argument.cellsize_deg          = {{ cellsize_selfcal_deg }}
premask_selfcal.argument.region_file           = {{ region_selfcal }}
premask_selfcal.argument.make_blank_image      = True
premask_selfcal.argument.trim_by               = 0.4

# image the concatenated data with wsclean, length = 1
wsclean_image02.control.type                    = wsclean
wsclean_image02.control.mapfiles_in             = [create_compressed_mapfile01.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image02.control.inputkeys               = [msfile,fitsmask]
wsclean_image02.argument.fits-mask              = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image02.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-join-channels,-save-source-list,msfile]
wsclean_image02.argument.channels-out           = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image02.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-save-source-list,msfile]
{% endif %}
wsclean_image02.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image02.argument.niter                  = 10000
wsclean_image02.argument.pol                    = I
wsclean_image02.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image02.argument.mgain                  = 0.8
wsclean_image02.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image02.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image02.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image02.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image02.argument.temp-dir               = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image02.argument.temp-dir               = {{ selfcal_local_dir }}
{% endif %}
wsclean_image02.argument.multiscale-shape       = gaussian
{% if not mscale_selfcal_do %}
wsclean_image02.argument.multiscale-scales      = 0
{% elif selfcal_multiscale_scales_pixel is not none %}
wsclean_image02.argument.multiscale-scales      = {{ selfcal_multiscale_scales_pixel }}
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image02.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image02.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image02.argument.weighting-rank-filter  = 3
wsclean_image02.argument.taper-gaussian         = 20arcsec
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image02.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image02.argument.auto-mask              = 2.6
{% else %}
wsclean_image02.argument.auto-mask              = 3.6
{% endif %}
wsclean_image02.argument.auto-threshold         = 0.5
wsclean_image02.argument.local-rms-window       = 50
wsclean_image02.argument.local-rms-method       = rms-with-min

# make compressed mapfile of concatenated data, length = ntimes
# needed for the wsclean_ft steps to get full frequency coverage per group
regroup_concat_data_map.control.kind               = plugin
regroup_concat_data_map.control.type               = compressMapfile
regroup_concat_data_map.control.mapfile_in         = {{ solve_concat_data_mapfile }}
regroup_concat_data_map.control.nitems_to_compress = {{ num_cal_blocks }}
regroup_concat_data_map.control.mapfile_dir        = input.output.mapfile_dir
regroup_concat_data_map.control.filename           = regroup_concat_data.mapfile

# generate mapfile for the fast-phase h5parms generated in the solve_phaseonly steps, length = ntimes * num_cal_blocks
make_fast_phase_h5parm_map.control.kind               = plugin
make_fast_phase_h5parm_map.control.type               = createMapfile
make_fast_phase_h5parm_map.control.method             = add_suffix_to_file
make_fast_phase_h5parm_map.control.mapfile_in         = concat_data.output.mapfile
make_fast_phase_h5parm_map.control.add_suffix_to_file = /instrument.h5
make_fast_phase_h5parm_map.control.mapfile_dir        = input.output.mapfile_dir
make_fast_phase_h5parm_map.control.filename           = fast_h5parm.mapfile

{% if peel_skymodel is not none %}
# create a mapfile with the outlier sky model from supplied list, length = 1
create_peel_skymodel_map.control.kind        = plugin
create_peel_skymodel_map.control.type        = addListMapfile
create_peel_skymodel_map.control.hosts       = {{ hosts }}
create_peel_skymodel_map.control.files       = [{{ peel_skymodel }}]
create_peel_skymodel_map.control.mapfile_dir = input.output.mapfile_dir
create_peel_skymodel_map.control.filename    = peel_skymodel.mapfile

# convert the outlier sky model into a sourcedb, length = 1
make_peel_sourcedb.control.type       = make_sourcedb
make_peel_sourcedb.control.mapfile_in = create_peel_skymodel_map.output.mapfile
make_peel_sourcedb.control.inputkey   = in
make_peel_sourcedb.argument.format    = <
make_peel_sourcedb.argument.outtype   = blob
make_peel_sourcedb.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_peel_sourcedb_map.control.kind             = plugin
expand_peel_sourcedb_map.control.type             = expandMapfile
expand_peel_sourcedb_map.control.mapfile_in       = make_peel_sourcedb.output.mapfile
expand_peel_sourcedb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_peel_sourcedb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_peel_sourcedb_map.control.filename         = expand_peel_sourcedb.mapfile

{% else %}

# group the WSClean sky model into a single patch, length = 1
group_skymodel0.control.type       = group_skymodel
group_skymodel0.control.mapfile_in = wsclean_image02.output.wsclean_image02-sources.txt.mapfile
group_skymodel0.control.inputkey   = inmod
group_skymodel0.control.outputkey  = outmod
group_skymodel0.argument.flags     = [inmod,outmod]

# convert the WSClean sky model into a sourcedb, length = 1
make_sourcedb0.control.type       = make_sourcedb
make_sourcedb0.control.mapfile_in = group_skymodel0.output.mapfile
make_sourcedb0.control.inputkey   = in
make_sourcedb0.argument.format    = <
make_sourcedb0.argument.outtype   = blob
make_sourcedb0.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_sourcedb0_map.control.kind             = plugin
expand_sourcedb0_map.control.type             = expandMapfile
expand_sourcedb0_map.control.mapfile_in       = make_sourcedb0.output.mapfile
expand_sourcedb0_map.control.mapfile_to_match = concat_data.output.mapfile
expand_sourcedb0_map.control.mapfile_dir      = input.output.mapfile_dir
expand_sourcedb0_map.control.filename         = expand_sourcedb0.mapfile
{% endif %}

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms1.control.type       = remove_file
remove_h5parms1.control.mapfile_in = make_fast_phase_h5parm_map.output.mapfile
remove_h5parms1.control.inputkey   = h5parm
remove_h5parms1.argument.flags     = [-rf,h5parm]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
solve_phaseonly1.control.type                         = dppp_inplace
{% if peel_skymodel is not none %}
solve_phaseonly1.control.mapfiles_in                  = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
{% else %}
solve_phaseonly1.control.mapfiles_in                  = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_sourcedb0_map.output.mapfile]
{% endif %}
solve_phaseonly1.control.inputkeys                    = [msin,h5parm,sourcedb]
solve_phaseonly1.argument.numthreads                  = {{ max_cpus_per_proc_ntimes }}
solve_phaseonly1.argument.msin.datacolumn             = DATA
solve_phaseonly1.argument.msout                       = .
solve_phaseonly1.argument.steps                       = [solvetec]
solve_phaseonly1.argument.solvetec.type               = ddecal
solve_phaseonly1.argument.solvetec.mode               = tecandphase
solve_phaseonly1.argument.solvetec.h5parm             = h5parm
solve_phaseonly1.argument.solvetec.sourcedb           = sourcedb
solve_phaseonly1.argument.solvetec.solint             = {{ solint_time_p }}
solve_phaseonly1.argument.solvetec.nchan              = {{ solint_freq_a }}
solve_phaseonly1.argument.solvetec.approximatetec     = {{ approximatetec }}
solve_phaseonly1.argument.solvetec.maxapproxiter      = {{ maxapproxiter }}
solve_phaseonly1.argument.solvetec.maxiter            = {{ maxiter }}
solve_phaseonly1.argument.solvetec.propagatesolutions = {{ propagatesolutions }}
solve_phaseonly1.argument.solvetec.stepsize           = {{ stepsize }}
solve_phaseonly1.argument.solvetec.tolerance          = {{ tolerance }}
solve_phaseonly1.argument.solvetec.uvlambdamin        = {{ solve_min_uv_lambda }}

########## end of first round of selfcal (20" resolution)
########## start of second round of selfcal (10" resolution)

{% if selfcal_local_dir is not none %}
# make mapfile for the output of apply steps, len = ntimes * num_cal_blocks
# this step is needed to direct the output to the shared disk if one is being
# used with mulitple nodes
make_apply_mapfile.control.kind         = plugin
make_apply_mapfile.control.type         = changeDirectory
{% if not pre_average %}
make_apply_mapfile.control.mapfile_in   = make_concat_data_sync_mapfile.output.mapfile
{% else %}
make_apply_mapfile.control.mapfile_in   = make_concat_blavg_data_sync_mapfile.output.mapfile
{% endif %}
make_apply_mapfile.control.new_dir      = {{ pipeline_parset_dir }}
make_apply_mapfile.control.append       = _apply_output
make_apply_mapfile.control.mapfile_dir  = input.output.mapfile_dir
make_apply_mapfile.control.filename     = apply_output.mapfile
{% endif %}

# apply the previous calibration and average, length = ntimes * num_cal_blocks
apply_phaseonly1.control.type                                 = dppp
apply_phaseonly1.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile]
apply_phaseonly1.control.inputkeys                            = [msin,h5parm]
{% if selfcal_local_dir is not none %}
apply_phaseonly1.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_phaseonly1.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_phaseonly1.argument.msin.datacolumn                     = DATA
apply_phaseonly1.argument.msout.overwrite                     = True
apply_phaseonly1.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_phaseonly1.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_phaseonly1.argument.steps                               = [correct_fast1,correct_fast2,avg]
apply_phaseonly1.argument.correct_fast1.type                  = applycal
apply_phaseonly1.argument.correct_fast1.parmdb                = h5parm
apply_phaseonly1.argument.correct_fast1.correction            = tec000
apply_phaseonly1.argument.correct_fast1.invert                = True
apply_phaseonly1.argument.correct_fast2.type                  = applycal
apply_phaseonly1.argument.correct_fast2.parmdb                = h5parm
apply_phaseonly1.argument.correct_fast2.correction            = phase000
apply_phaseonly1.argument.correct_fast2.invert                = True
apply_phaseonly1.argument.avg.type                            = squash
apply_phaseonly1.argument.avg.freqstep                        = 1
apply_phaseonly1.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_phaseonly1.argument.msout.storagemanager                = "Dysco"
apply_phaseonly1.argument.msout.storagemanager.databitrate    = 16
apply_phaseonly1.argument.msout.storagemanager.weightbitrate  = 12
apply_phaseonly1.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_phaseonly1.argument.msout.storagemanager.disttruncation = 1.5
apply_phaseonly1.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile1.control.kind        = plugin
create_compressed_mapfile1.control.type        = compressMapfile
create_compressed_mapfile1.control.mapfile_in  = apply_phaseonly1.output.mapfile
create_compressed_mapfile1.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile1.control.filename    = image1_input.mapfile

# image the concatenated data with wsclean, length = 1
wsclean_image12.control.type                    = wsclean
wsclean_image12.control.mapfiles_in             = [create_compressed_mapfile1.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image12.control.inputkeys               = [msfile,fitsmask]
wsclean_image12.argument.fits-mask              = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image12.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-join-channels,-save-source-list,msfile]
wsclean_image12.argument.channels-out           = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image12.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-save-source-list,msfile]
{% endif %}
wsclean_image12.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image12.argument.niter                  = 10000
wsclean_image12.argument.pol                    = I
wsclean_image12.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image12.argument.mgain                  = 0.8
wsclean_image12.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image12.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image12.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image12.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image12.argument.temp-dir               = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image12.argument.temp-dir               = {{ selfcal_local_dir }}
{% endif %}
wsclean_image12.argument.multiscale-shape       = gaussian
{% if not mscale_selfcal_do %}
wsclean_image12.argument.multiscale-scales      = 0
{% elif selfcal_multiscale_scales_pixel is not none %}
wsclean_image12.argument.multiscale-scales      = {{ selfcal_multiscale_scales_pixel }}
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image12.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image12.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image12.argument.weighting-rank-filter  = 3
wsclean_image12.argument.taper-gaussian         = 10arcsec
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image12.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image12.argument.auto-mask              = 2.3
{% else %}
wsclean_image12.argument.auto-mask              = 3.3
{% endif %}
wsclean_image12.argument.auto-threshold         = 0.5
wsclean_image12.argument.local-rms-window       = 50
wsclean_image12.argument.local-rms-method       = rms-with-min

# group the WSClean sky model into a single patch, length = 1
group_skymodel1.control.type       = group_skymodel
group_skymodel1.control.mapfile_in = wsclean_image12.output.wsclean_image12-sources.txt.mapfile
group_skymodel1.control.inputkey   = inmod
group_skymodel1.control.outputkey  = outmod
group_skymodel1.argument.flags     = [inmod,outmod]

# convert the WSClean sky model into a sourcedb, length = 1
make_sourcedb1.control.type       = make_sourcedb
make_sourcedb1.control.mapfile_in = group_skymodel1.output.mapfile
make_sourcedb1.control.inputkey   = in
make_sourcedb1.argument.format    = <
make_sourcedb1.argument.outtype   = blob
make_sourcedb1.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_sourcedb1_map.control.kind             = plugin
expand_sourcedb1_map.control.type             = expandMapfile
expand_sourcedb1_map.control.mapfile_in       = make_sourcedb1.output.mapfile
expand_sourcedb1_map.control.mapfile_to_match = concat_data.output.mapfile
expand_sourcedb1_map.control.mapfile_dir      = input.output.mapfile_dir
expand_sourcedb1_map.control.filename         = expand_sourcedb1.mapfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms2.control.type       = remove_file
remove_h5parms2.control.mapfile_in = make_fast_phase_h5parm_map.output.mapfile
remove_h5parms2.control.inputkey   = h5parm
remove_h5parms2.argument.flags     = [-rf,h5parm]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
solve_phaseonly2.control.type                         = dppp_inplace
solve_phaseonly2.control.mapfiles_in                  = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,,expand_sourcedb1_map.output.mapfile]
solve_phaseonly2.control.inputkeys                    = [msin,h5parm,sourcedb]
solve_phaseonly2.argument.numthreads                  = {{ max_cpus_per_proc_ntimes }}
solve_phaseonly2.argument.msin.datacolumn             = DATA
solve_phaseonly2.argument.msout                       = .
solve_phaseonly2.argument.steps                       = [solvetec]
solve_phaseonly2.argument.solvetec.type               = ddecal
solve_phaseonly2.argument.solvetec.mode               = tecandphase
solve_phaseonly2.argument.solvetec.h5parm             = h5parm
solve_phaseonly2.argument.solvetec.sourcedb           = sourcedb
solve_phaseonly2.argument.solvetec.solint             = {{ solint_time_p }}
solve_phaseonly2.argument.solvetec.nchan              = {{ solint_freq_a }}
solve_phaseonly2.argument.solvetec.approximatetec     = {{ approximatetec }}
solve_phaseonly2.argument.solvetec.maxapproxiter      = {{ maxapproxiter }}
solve_phaseonly2.argument.solvetec.maxiter            = {{ maxiter }}
solve_phaseonly2.argument.solvetec.propagatesolutions = {{ propagatesolutions }}
solve_phaseonly2.argument.solvetec.stepsize           = {{ stepsize }}
solve_phaseonly2.argument.solvetec.tolerance          = {{ tolerance }}
solve_phaseonly2.argument.solvetec.uvlambdamin        = {{ solve_min_uv_lambda }}

########## end of second round of selfcal
########## start of third round of selfcal

# apply the previous calibration, length = ntimes * num_cal_blocks
apply_phaseonly2.control.type                      = dppp_inplace
apply_phaseonly2.control.mapfiles_in               = [{{ concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile]
apply_phaseonly2.control.inputkeys                 = [msin,h5parm]
apply_phaseonly2.argument.numthreads               = {{ max_cpus_per_proc_ntimes }}
apply_phaseonly2.argument.msin.datacolumn          = DATA
apply_phaseonly2.argument.msout                    = .
apply_phaseonly2.argument.msout.datacolumn         = CORRECTED_DATA
apply_phaseonly2.argument.steps                    = [correct_fast1,correct_fast2]
apply_phaseonly2.argument.correct_fast1.type       = applycal
apply_phaseonly2.argument.correct_fast1.parmdb     = h5parm
apply_phaseonly2.argument.correct_fast1.correction = tec000
apply_phaseonly2.argument.correct_fast1.invert     = True
apply_phaseonly2.argument.correct_fast2.type       = applycal
apply_phaseonly2.argument.correct_fast2.parmdb     = h5parm
apply_phaseonly2.argument.correct_fast2.correction = phase000
apply_phaseonly2.argument.correct_fast2.invert     = True

########## end of second round of selfcal (10" resolution)
########## start of phase-only selfcal loop

# loop step
loop_phasecal.control.kind      = loop
loop_phasecal.control.type      = conditional
loop_phasecal.control.loopcount = {{ loopcount }}
loop_phasecal.control.loopsteps = [average2,create_compressed_mapfile2,wsclean_image22,create_imagebase_map22,group_skymodel2,make_sourcedb2,expand_sourcedb2_map,remove_h5parms11,solve_ampphase11,apply_ampphase11,adjust_wsclean_mapfile22_phaseloop,copy_image1,check_image1]

# average the output of the previous apply step, length = ntimes * num_cal_blocks
average2.control.type                                 = dppp
average2.control.mapfile_in                           = {{ concat_data_mapfile }}
average2.control.inputkey                             = msin
{% if selfcal_local_dir is not none %}
average2.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
average2.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average2.argument.msin.datacolumn                     = CORRECTED_DATA
average2.argument.msout.overwrite                     = True
average2.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average2.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average2.argument.steps                               = [avg]
average2.argument.avg.type                            = squash
average2.argument.avg.freqstep                        = 1
average2.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
average2.argument.msout.storagemanager                = "Dysco"
average2.argument.msout.storagemanager.databitrate    = 16
average2.argument.msout.storagemanager.weightbitrate  = 12
average2.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average2.argument.msout.storagemanager.disttruncation = 1.5
average2.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile2.control.kind        = plugin
create_compressed_mapfile2.control.type        = compressMapfile
create_compressed_mapfile2.control.mapfile_in  = average2.output.mapfile
create_compressed_mapfile2.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile2.control.filename    = image2_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image22.control.type                    = wsclean
wsclean_image22.control.mapfiles_in             = [create_compressed_mapfile2.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image22.control.inputkeys               = [msfile,fitsmask]
wsclean_image22.argument.fits-mask              = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image22.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-join-channels,-save-source-list,msfile]
wsclean_image22.argument.channels-out           = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image22.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-save-source-list,msfile]
{% endif %}
wsclean_image22.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image22.argument.niter                  = 10000
wsclean_image22.argument.pol                    = I
wsclean_image22.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image22.argument.mgain                  = 0.8
wsclean_image22.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image22.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image22.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image22.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image22.argument.temp-dir               = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image22.argument.temp-dir               = {{ selfcal_local_dir }}
{% endif %}
wsclean_image22.argument.multiscale-shape       = gaussian
{% if not mscale_selfcal_do %}
wsclean_image22.argument.multiscale-scales      = 0,7
{% elif selfcal_multiscale_scales_pixel is not none %}
wsclean_image22.argument.multiscale-scales      = {{ selfcal_multiscale_scales_pixel }}
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image22.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image22.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image22.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image22.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image22.argument.auto-mask              = 2.0
{% else %}
wsclean_image22.argument.auto-mask              = 3.0
{% endif %}
wsclean_image22.argument.auto-threshold         = 0.5
wsclean_image22.argument.local-rms-window       = 50
wsclean_image22.argument.local-rms-method       = rms-with-min
wsclean_image22.argument.multiscale-scale-bias  = 0.5
wsclean_image22.argument.multiscale-gain        = 0.1

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map22.control.kind        = plugin
create_imagebase_map22.control.type        = trimMapfile
create_imagebase_map22.control.mapfile_in  = wsclean_image22.output.wsclean_image22-image.fits.mapfile
create_imagebase_map22.control.trim        = -
create_imagebase_map22.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map22.control.filename    = wsclean_image22_image_rootname.mapfile

# group the WSClean sky model into a single patch, length = 1
group_skymodel2.control.type       = group_skymodel
group_skymodel2.control.mapfile_in = wsclean_image22.output.wsclean_image22-sources.txt.mapfile
group_skymodel2.control.inputkey   = inmod
group_skymodel2.control.outputkey  = outmod
group_skymodel2.argument.flags     = [inmod,outmod]

# convert the WSClean sky model into a sourcedb, length = 1
make_sourcedb2.control.type       = make_sourcedb
make_sourcedb2.control.mapfile_in = group_skymodel2.output.mapfile
make_sourcedb2.control.inputkey   = in
make_sourcedb2.argument.format    = <
make_sourcedb2.argument.outtype   = blob
make_sourcedb2.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_sourcedb2_map.control.kind             = plugin
expand_sourcedb2_map.control.type             = expandMapfile
expand_sourcedb2_map.control.mapfile_in       = make_sourcedb2.output.mapfile
expand_sourcedb2_map.control.mapfile_to_match = concat_data.output.mapfile
expand_sourcedb2_map.control.mapfile_dir      = input.output.mapfile_dir
expand_sourcedb2_map.control.filename         = expand_sourcedb2.mapfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms11.control.type       = remove_file
remove_h5parms11.control.mapfile_in = make_fast_phase_h5parm_map.output.mapfile
remove_h5parms11.control.inputkey   = h5parm
remove_h5parms11.argument.flags     = [-rf,h5parm]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
solve_ampphase11.control.type                         = dppp_inplace
solve_ampphase11.control.mapfiles_in                  = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_sourcedb2_map.output.mapfile]
solve_ampphase11.control.inputkeys                    = [msin,h5parm,sourcedb]
solve_ampphase11.argument.numthreads                  = {{ max_cpus_per_proc_ntimes }}
solve_ampphase11.argument.msin.datacolumn             = DATA
solve_ampphase11.argument.msout                       = .
solve_ampphase11.argument.steps                       = [solvetec]
solve_ampphase11.argument.solvetec.type               = ddecal
solve_ampphase11.argument.solvetec.mode               = tecandphase
solve_ampphase11.argument.solvetec.h5parm             = h5parm
solve_ampphase11.argument.solvetec.sourcedb           = sourcedb
solve_ampphase11.argument.solvetec.solint             = {{ solint_time_p }}
solve_ampphase11.argument.solvetec.nchan              = {{ solint_freq_a }}
solve_ampphase11.argument.solvetec.approximatetec     = {{ approximatetec }}
solve_ampphase11.argument.solvetec.maxapproxiter      = {{ maxapproxiter }}
solve_ampphase11.argument.solvetec.maxiter            = {{ maxiter }}
solve_ampphase11.argument.solvetec.propagatesolutions = {{ propagatesolutions }}
solve_ampphase11.argument.solvetec.stepsize           = {{ stepsize }}
solve_ampphase11.argument.solvetec.tolerance          = {{ tolerance }}
solve_ampphase11.argument.solvetec.uvlambdamin        = {{ solve_min_uv_lambda }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase11.control.type                                 = dppp_inplace
apply_ampphase11.control.mapfiles_in                          = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile]
apply_ampphase11.control.inputkeys                            = [msin,h5parm]
apply_ampphase11.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase11.argument.msin.datacolumn                     = DATA
apply_ampphase11.argument.msout                               = .
apply_ampphase11.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase11.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase11.argument.correct_fast1.type                  = applycal
apply_ampphase11.argument.correct_fast1.parmdb                = h5parm
apply_ampphase11.argument.correct_fast1.correction            = tec000
apply_ampphase11.argument.correct_fast1.invert                = True
apply_ampphase11.argument.correct_fast2.type                  = applycal
apply_ampphase11.argument.correct_fast2.parmdb                = h5parm
apply_ampphase11.argument.correct_fast2.correction            = phase000
apply_ampphase11.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase11.argument.msout.storagemanager                = "Dysco"
apply_ampphase11.argument.msout.storagemanager.databitrate    = 16
apply_ampphase11.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase11.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase11.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase11.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# fiddle with the image mapfiles, length = 1
adjust_wsclean_mapfile22_phaseloop.control.kind        = plugin
adjust_wsclean_mapfile22_phaseloop.control.type        = appendMapfile
adjust_wsclean_mapfile22_phaseloop.control.mapfile_in  = create_imagebase_map22.output.mapfile
adjust_wsclean_mapfile22_phaseloop.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile22_phaseloop.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile22_phaseloop.control.filename    = compare_image_input_new1.mapfile

# copy the output image so that we can compare it later, length = 1
copy_image1.control.type       = copy_image
copy_image1.control.mapfile_in = adjust_wsclean_mapfile22_phaseloop.output.mapfile
copy_image1.control.inputkey   = image
copy_image1.argument.flags     = [image,loop_phasecal.output.counter,2]

# compare the current and the previous image to see if we can stop the loop, length = 1
check_image1.control.type        = compare_image_stats
check_image1.control.mapfiles_in = [adjust_wsclean_mapfile22_phaseloop.output.mapfile,copy_image1.output.previous_image.mapfile]
check_image1.control.inputkeys   = [image_new,image_prev]
check_image1.argument.flags      = [image_new,image_prev,loop_phasecal.output.counter,1.05]

###### end of phase-only selfcal loop
###### continue to amplitude calibration

# generate mapfile for the slow-gain parmDBs generated in the solve_ampphase12 step
make_slow_gain_h5parm_map.control.kind               =  plugin
make_slow_gain_h5parm_map.control.type               =  createMapfile
make_slow_gain_h5parm_map.control.method             =  add_suffix_to_file
make_slow_gain_h5parm_map.control.mapfile_in         =  concat_data.output.mapfile
make_slow_gain_h5parm_map.control.add_suffix_to_file =  /instrument_slow.h5
make_slow_gain_h5parm_map.control.mapfile_dir        =  input.output.mapfile_dir
make_slow_gain_h5parm_map.control.filename           =  slow_h5parm.mapfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms12.control.type       = remove_file
remove_h5parms12.control.mapfile_in = make_slow_gain_h5parm_map.output.mapfile
remove_h5parms12.control.inputkey   = h5parm
remove_h5parms12.argument.flags     = [-rf,h5parm]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes
solve_ampphase12.control.type                            = dppp_inplace
solve_ampphase12.control.mapfiles_in                     = [{{ solve_concat_data_mapfile }},make_slow_gain_h5parm_map.output.mapfile,expand_sourcedb2_map.output.mapfile]
solve_ampphase12.control.inputkeys                       = [msin,h5parm,sourcedb]
solve_ampphase12.argument.numthreads                     = {{ max_cpus_per_proc_ntimes }}
solve_ampphase12.argument.msin.datacolumn                = CORRECTED_DATA
solve_ampphase12.argument.msout                          = .
solve_ampphase12.argument.steps                          = [solvegain]
solve_ampphase12.argument.solvegain.type                 = ddecal
solve_ampphase12.argument.solvegain.mode                 = complexgain
solve_ampphase12.argument.solvegain.h5parm               = h5parm
solve_ampphase12.argument.solvegain.sourcedb             = sourcedb
solve_ampphase12.argument.solvegain.solint               = {{ solint_time_a }}
solve_ampphase12.argument.solvegain.nchan                = {{ solint_freq_a }}
solve_ampphase12.argument.solvegain.maxiter              = {{ maxiter }}
solve_ampphase12.argument.solvegain.propagatesolutions   = {{ propagatesolutions }}
solve_ampphase12.argument.solvegain.stepsize             = {{ stepsize }}
solve_ampphase12.argument.solvegain.tolerance            = {{ tolerance }}
solve_ampphase12.argument.solvegain.uvlambdamin          = {{ solve_min_uv_lambda }}
solve_ampphase12.argument.solvegain.smoothnessconstraint = 6e6

# compress slow-gain mapfile so that all files are in one group, length = 1
create_compressed_mapfile_slow.control.kind        = plugin
create_compressed_mapfile_slow.control.type        = compressMapfile
create_compressed_mapfile_slow.control.mapfile_in  = make_slow_gain_h5parm_map.output.mapfile
create_compressed_mapfile_slow.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile_slow.control.filename    = compress_slow.mapfile

# create a mapfile for output of combine step, length = 1
create_combined_slow_output_map.control.kind        = plugin
create_combined_slow_output_map.control.type        = addListMapfile
create_combined_slow_output_map.control.hosts       = {{ hosts }}
create_combined_slow_output_map.control.files       = [input.output.working_directory/input.output.job_name/slow_gains.h5]
create_combined_slow_output_map.control.mapfile_dir = input.output.mapfile_dir
create_combined_slow_output_map.control.filename    = combine_slow_h5parms_output.mapfile

# match the host before combining, length = 1
match_host_slow.control.kind             = plugin
match_host_slow.control.type             = matchHosts
match_host_slow.control.mapfile_in       = create_compressed_mapfile_slow.output.mapfile
match_host_slow.control.mapfile_to_match = create_combined_slow_output_map.output.mapfile
match_host_slow.control.mapfile_dir      = input.output.mapfile_dir
match_host_slow.control.filename         = match_host_slow.mapfile

# collect all the slow-gain solutions, length = ntimes -> 1
combine_slow_gains1.control.type        = collect_h5parms
combine_slow_gains1.control.mapfile_in  = create_compressed_mapfile_slow.output.mapfile
combine_slow_gains1.control.inputkey    = infiles
combine_slow_gains1.control.mapfile_out = create_combined_slow_output_map.output.mapfile
combine_slow_gains1.control.outputkey   = outfile
combine_slow_gains1.argument.flags      = [-c,infiles]
combine_slow_gains1.argument.outh5parm  = outfile

# smooth the amplitues in the merged h5parm, length = 1
smooth_amp1.control.type         = {{ smooth_amps_task }}
smooth_amp1.control.mapfile_in   = combine_slow_gains1.output.mapfile
smooth_amp1.control.inputkey     = amph5parm
smooth_amp1.argument.flags       = [amph5parm]

# expand the mapfile with the smoothd h5parm to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp1_h5parm_map.control.kind             = plugin
expand_smoothed_amp1_h5parm_map.control.type             = expandMapfile
expand_smoothed_amp1_h5parm_map.control.mapfile_in       = smooth_amp1.output.mapfile
expand_smoothed_amp1_h5parm_map.control.mapfile_to_match = concat_data.output.mapfile
expand_smoothed_amp1_h5parm_map.control.mapfile_dir      = input.output.mapfile_dir
expand_smoothed_amp1_h5parm_map.control.filename         = expand_amp1_smoothed_h5parms.mapfile

# apply the solutions and average, length = ntimes * num_cal_blocks
apply_amp1.control.type                                 = dppp
{% if selfcal_local_dir is not none %}
apply_amp1.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_amp1.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
{% if not pre_average %}
apply_amp1.control.mapfiles_in                          = [{{ concat_data_mapfile }},expand_smoothed_amp1_h5parm_map.output.mapfile]
apply_amp1.control.inputkeys                            = [msin,slow_h5parm]
apply_amp1.argument.msin.datacolumn                     = CORRECTED_DATA
apply_amp1.argument.steps                               = [correct_slow_amp,correct_slow_phase,avg]
{% else %}
apply_amp1.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_smoothed_amp1_h5parm_map.output.mapfile]
apply_amp1.control.inputkeys                            = [msin,fast_h5parmdb,slow_h5parm]
apply_amp1.argument.msin.datacolumn                     = DATA
apply_amp1.argument.steps                               = [correct_fast1,correct_fast2,correct_slow_amp,correct_slow_phase,avg]
apply_amp1.argument.correct_fast1.type                  = applycal
apply_amp1.argument.correct_fast1.parmdb                = fast_h5parm
apply_amp1.argument.correct_fast1.correction            = tec000
apply_amp1.argument.correct_fast1.invert                = True
apply_amp1.argument.correct_fast2.type                  = applycal
apply_amp1.argument.correct_fast2.parmdb                = fast_h5parm
apply_amp1.argument.correct_fast2.correction            = phase000
apply_amp1.argument.correct_fast2.invert                = True
{% endif %}
apply_amp1.argument.msout.overwrite                     = True
apply_amp1.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_amp1.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_amp1.argument.correct_slow_amp.type               = applycal
apply_amp1.argument.correct_slow_amp.parmdb             = slow_h5parm
apply_amp1.argument.correct_slow_amp.correction         = amplitude001
apply_amp1.argument.correct_slow_amp.invert             = True
apply_amp1.argument.correct_slow_phase.type             = applycal
apply_amp1.argument.correct_slow_phase.parmdb           = slow_h5parm
apply_amp1.argument.correct_slow_phase.correction       = phase000
apply_amp1.argument.correct_slow_phase.invert           = True
apply_amp1.argument.avg.type                            = squash
apply_amp1.argument.avg.freqstep                        = 1
apply_amp1.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp1.argument.msout.storagemanager                = "Dysco"
apply_amp1.argument.msout.storagemanager.databitrate    = 16
apply_amp1.argument.msout.storagemanager.weightbitrate  = 12
apply_amp1.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_amp1.argument.msout.storagemanager.disttruncation = 1.5
apply_amp1.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

########## end of third round of selfcal
########## start of fourth round of selfcal

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile3.control.kind        = plugin
create_compressed_mapfile3.control.type        = compressMapfile
create_compressed_mapfile3.control.mapfile_in  = apply_amp1.output.mapfile
create_compressed_mapfile3.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile3.control.filename    = image3_input.mapfile

# image the concatenated data with wsclean, length = 1
wsclean_image32.control.type                    = wsclean
wsclean_image32.control.mapfiles_in             = [create_compressed_mapfile3.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image32.control.inputkeys               = [msfile,fitsmask]
wsclean_image32.argument.fits-mask              = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image32.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-join-channels,-save-source-list,msfile]
wsclean_image32.argument.channels-out           = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image32.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-save-source-list,msfile]
{% endif %}
wsclean_image32.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image32.argument.niter                  = 10000
wsclean_image32.argument.pol                    = I
wsclean_image32.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image32.argument.mgain                  = 0.8
wsclean_image32.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image32.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image32.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image32.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image32.argument.temp-dir               = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image32.argument.temp-dir               = {{ selfcal_local_dir }}
{% endif %}
wsclean_image32.argument.multiscale-shape       = gaussian
{% if not mscale_selfcal_do %}
wsclean_image32.argument.multiscale-scales      = 0,7
{% elif selfcal_multiscale_scales_pixel is not none %}
wsclean_image32.argument.multiscale-scales      = {{ selfcal_multiscale_scales_pixel }}
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image32.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image32.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image32.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image32.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image32.argument.auto-mask              = 2.5
{% else %}
wsclean_image32.argument.auto-mask              = 3.5
{% endif %}
wsclean_image32.argument.auto-threshold         = 0.5
wsclean_image32.argument.local-rms-window       = 50
wsclean_image32.argument.local-rms-method       = rms-with-min
wsclean_image32.argument.multiscale-scale-bias  = 0.5
wsclean_image32.argument.multiscale-gain        = 0.1

########## start of phase+amp selfcal loop

# loop step
loop_ampcal.control.kind      = loop
loop_ampcal.control.type      = conditional
loop_ampcal.control.loopcount = {{ loopcount }}
loop_ampcal.control.loopsteps = [group_skymodel3,make_sourcedb3,expand_sourcedb3_map,remove_h5parms21,solve_ampphase21,apply_ampphase21,create_compressed_mapfile_fast,create_combined_fast_output_map,match_host_fast,merge_phase_h5parms,remove_h5parms22,solve_ampphase22,combine_slow_gains2,smooth_amp2,expand_smoothed_amp2_h5parm_map,apply_amp2,create_compressed_mapfile4,wsclean_image42,create_imagebase_map42,adjust_wsclean_mapfile42,copy_image2,check_image2]

# group the WSClean sky model into a single patch, length = 1
group_skymodel3.control.type       = group_skymodel
group_skymodel3.control.mapfile_in = wsclean_image32.output.wsclean_image32-sources.txt.mapfile
group_skymodel3.control.inputkey   = inmod
group_skymodel3.control.outputkey  = outmod
group_skymodel3.argument.flags     = [inmod,outmod]

# convert the WSClean sky model into a sourcedb, length = 1
make_sourcedb3.control.type       = make_sourcedb
make_sourcedb3.control.mapfile_in = group_skymodel3.output.mapfile
make_sourcedb3.control.inputkey   = in
make_sourcedb3.argument.format    = <
make_sourcedb3.argument.outtype   = blob
make_sourcedb3.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_sourcedb3_map.control.kind             = plugin
expand_sourcedb3_map.control.type             = expandMapfile
expand_sourcedb3_map.control.mapfile_in       = make_sourcedb3.output.mapfile
expand_sourcedb3_map.control.mapfile_to_match = concat_data.output.mapfile
expand_sourcedb3_map.control.mapfile_dir      = input.output.mapfile_dir
expand_sourcedb3_map.control.filename         = expand_sourcedb3.mapfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms21.control.type       = remove_file
remove_h5parms21.control.mapfile_in = make_fast_phase_h5parm_map.output.mapfile
remove_h5parms21.control.inputkey   = h5parm
remove_h5parms21.argument.flags     = [-rf,h5parm]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
solve_ampphase21.control.type                         = dppp_inplace
solve_ampphase21.control.mapfiles_in                  = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_sourcedb3_map.output.mapfile]
solve_ampphase21.control.inputkeys                    = [msin,h5parm,sourcedb]
solve_ampphase21.argument.numthreads                  = {{ max_cpus_per_proc_ntimes }}
solve_ampphase21.argument.msin.datacolumn             = DATA
solve_ampphase21.argument.msout                       = .
solve_ampphase21.argument.steps                       = [solvetec]
solve_ampphase21.argument.solvetec.uvlambdamin        = {{ solve_min_uv_lambda }}
solve_ampphase21.argument.solvetec.type               = ddecal
solve_ampphase21.argument.solvetec.mode               = tecandphase
solve_ampphase21.argument.solvetec.h5parm             = h5parm
solve_ampphase21.argument.solvetec.sourcedb           = sourcedb
solve_ampphase21.argument.solvetec.solint             = {{ solint_time_p }}
solve_ampphase21.argument.solvetec.nchan              = {{ solint_freq_a }}
solve_ampphase21.argument.solvetec.approximatetec     = {{ approximatetec }}
solve_ampphase21.argument.solvetec.maxapproxiter      = {{ maxapproxiter }}
solve_ampphase21.argument.solvetec.maxiter            = {{ maxiter }}
solve_ampphase21.argument.solvetec.propagatesolutions = {{ propagatesolutions }}
solve_ampphase21.argument.solvetec.stepsize           = {{ stepsize }}
solve_ampphase21.argument.solvetec.tolerance          = {{ tolerance }}
solve_ampphase21.argument.solvetec.uvlambdamin        = {{ solve_min_uv_lambda }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase21.control.type                                 = dppp_inplace
apply_ampphase21.control.mapfiles_in                          = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile]
apply_ampphase21.control.inputkeys                            = [msin,h5parm]
apply_ampphase21.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase21.argument.msin.datacolumn                     = DATA
apply_ampphase21.argument.msout                               = .
apply_ampphase21.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase21.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase21.argument.correct_fast1.type                  = applycal
apply_ampphase21.argument.correct_fast1.parmdb                = h5parm
apply_ampphase21.argument.correct_fast1.correction            = tec000
apply_ampphase21.argument.correct_fast1.invert                = True
apply_ampphase21.argument.correct_fast2.type                  = applycal
apply_ampphase21.argument.correct_fast2.parmdb                = h5parm
apply_ampphase21.argument.correct_fast2.correction            = phase000
apply_ampphase21.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase21.argument.msout.storagemanager                = "Dysco"
apply_ampphase21.argument.msout.storagemanager.databitrate    = 16
apply_ampphase21.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase21.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase21.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase21.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# compress fast-phase mapfile so that all files are in one group, length = 1
create_compressed_mapfile_fast.control.kind        = plugin
create_compressed_mapfile_fast.control.type        = compressMapfile
create_compressed_mapfile_fast.control.mapfile_in  = make_fast_phase_h5parm_map.output.mapfile
create_compressed_mapfile_fast.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile_fast.control.filename    = compress_fast.mapfile

# create a mapfile for output of combine step, length = 1
create_combined_fast_output_map.control.kind        = plugin
create_combined_fast_output_map.control.type        = addListMapfile
create_combined_fast_output_map.control.hosts       = {{ hosts }}
create_combined_fast_output_map.control.files       = [input.output.working_directory/input.output.job_name/fast_phases.h5]
create_combined_fast_output_map.control.mapfile_dir = input.output.mapfile_dir
create_combined_fast_output_map.control.filename    = combine_fast_h5parms_output.mapfile

# match the host before combining, length = 1
match_host_fast.control.kind             = plugin
match_host_fast.control.type             = matchHosts
match_host_fast.control.mapfile_in       = create_compressed_mapfile_fast.output.mapfile
match_host_fast.control.mapfile_to_match = create_combined_fast_output_map.output.mapfile
match_host_fast.control.mapfile_dir      = input.output.mapfile_dir
match_host_fast.control.filename         = match_host_slow.mapfile

# merge the h5parms with the phase solutions into one, length = 1
# This is needed later when the loop is done and we want to apply the solutions to the original data
merge_phase_h5parms.control.type        = collect_h5parms
merge_phase_h5parms.control.mapfile_in  = create_compressed_mapfile_fast.output.mapfile
merge_phase_h5parms.control.inputkey    = infiles
merge_phase_h5parms.control.mapfile_out = create_combined_fast_output_map.output.mapfile
merge_phase_h5parms.control.outputkey   = outfile
merge_phase_h5parms.argument.flags      = [-c,infiles]
merge_phase_h5parms.argument.outh5parm  = outfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms22.control.type       = remove_file
remove_h5parms22.control.mapfile_in = make_slow_gain_h5parm_map.output.mapfile
remove_h5parms22.control.inputkey   = h5parm
remove_h5parms22.argument.flags     = [-rf,h5parm]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
solve_ampphase22.control.type                            = dppp_inplace
solve_ampphase22.control.mapfiles_in                     = [{{ solve_concat_data_mapfile }},make_slow_gain_h5parm_map.output.mapfile,expand_sourcedb3_map.output.mapfile]
solve_ampphase22.control.inputkeys                       = [msin,h5parm,sourcedb]
solve_ampphase22.argument.numthreads                     = {{ max_cpus_per_proc_ntimes }}
solve_ampphase22.argument.msin.datacolumn                = CORRECTED_DATA
solve_ampphase22.argument.msout                          = .
solve_ampphase22.argument.steps                          = [solvegain]
solve_ampphase22.argument.solvegain.type                 = ddecal
solve_ampphase22.argument.solvegain.mode                 = complexgain
solve_ampphase22.argument.solvegain.h5parm               = h5parm
solve_ampphase22.argument.solvegain.sourcedb             = sourcedb
solve_ampphase22.argument.solvegain.solint               = {{ solint_time_a }}
solve_ampphase22.argument.solvegain.nchan                = {{ solint_freq_a }}
solve_ampphase22.argument.solvegain.maxiter              = {{ maxiter }}
solve_ampphase22.argument.solvegain.propagatesolutions   = {{ propagatesolutions }}
solve_ampphase22.argument.solvegain.stepsize             = {{ stepsize }}
solve_ampphase22.argument.solvegain.tolerance            = {{ tolerance }}
solve_ampphase22.argument.solvegain.uvlambdamin          = {{ solve_min_uv_lambda }}
solve_ampphase22.argument.solvegain.smoothnessconstraint = 6e6

# merge the h5parms with the amplitude solutions into one, length = 1
# This is also used after the loop, but also now for smoothing the amplitudes
# collect all the slow-gain solutions, length = ntimes -> 1
combine_slow_gains2.control.type        = collect_h5parms
combine_slow_gains2.control.mapfile_in  = create_compressed_mapfile_slow.output.mapfile
combine_slow_gains2.control.inputkey    = infiles
combine_slow_gains2.control.mapfile_out = create_combined_slow_output_map.output.mapfile
combine_slow_gains2.control.outputkey   = outfile
combine_slow_gains2.argument.flags      = [-c,infiles]
combine_slow_gains2.argument.outh5parm  = outfile

# smooth the amplitues in the merged h5parm, length = 1
smooth_amp2.control.type         = {{ smooth_amps_task }}
smooth_amp2.control.mapfile_in   = combine_slow_gains2.output.mapfile
smooth_amp2.control.inputkey     = amph5parm
smooth_amp2.argument.flags       = [amph5parm]

# expand the mapfile with the smoothd h5parm to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp2_h5parm_map.control.kind             = plugin
expand_smoothed_amp2_h5parm_map.control.type             = expandMapfile
expand_smoothed_amp2_h5parm_map.control.mapfile_in       = smooth_amp2.output.mapfile
expand_smoothed_amp2_h5parm_map.control.mapfile_to_match = concat_data.output.mapfile
expand_smoothed_amp2_h5parm_map.control.mapfile_dir      = input.output.mapfile_dir
expand_smoothed_amp2_h5parm_map.control.filename         = expand_amp2_smoothed_h5parms.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp2.control.type                                 = dppp
{% if selfcal_local_dir is not none %}
apply_amp2.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_amp2.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
{% if not pre_average %}
apply_amp2.control.mapfiles_in                          = [{{ concat_data_mapfile }},expand_smoothed_amp2_h5parm_map.output.mapfile]
apply_amp2.control.inputkeys                            = [msin,slow_h5parm]
apply_amp2.argument.msin.datacolumn                     = CORRECTED_DATA
apply_amp2.argument.steps                               = [correct_slow_amp,correct_slow_phase,avg]
{% else %}
apply_amp2.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_smoothed_amp2_h5parm_map.output.mapfile]
apply_amp2.control.inputkeys                            = [msin,fast_h5parmdb,slow_h5parm]
apply_amp2.argument.msin.datacolumn                     = DATA
apply_amp2.argument.steps                               = [correct_fast1,correct_fast2,correct_slow_amp,correct_slow_phase,avg]
apply_amp2.argument.correct_fast1.type                  = applycal
apply_amp2.argument.correct_fast1.parmdb                = fast_h5parmdb
apply_amp2.argument.correct_fast1.correction            = tec000
apply_amp2.argument.correct_fast1.invert                = True
apply_amp2.argument.correct_fast2.type                  = applycal
apply_amp2.argument.correct_fast2.parmdb                = fast_h5parmdb
apply_amp2.argument.correct_fast2.correction            = phase000
apply_amp2.argument.correct_fast2.invert                = True
{% endif %}
apply_amp2.argument.msout.overwrite                     = True
apply_amp2.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_amp2.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_amp2.argument.correct_slow_amp.type               = applycal
apply_amp2.argument.correct_slow_amp.parmdb             = slow_h5parm
apply_amp2.argument.correct_slow_amp.correction         = amplitude001
apply_amp2.argument.correct_slow_amp.invert             = True
apply_amp2.argument.correct_slow_phase.type             = applycal
apply_amp2.argument.correct_slow_phase.parmdb           = slow_h5parm
apply_amp2.argument.correct_slow_phase.correction       = phase000
apply_amp2.argument.correct_slow_phase.invert           = True
apply_amp2.argument.avg.type                            = squash
apply_amp2.argument.avg.freqstep                        = 1
apply_amp2.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp2.argument.msout.storagemanager                = "Dysco"
apply_amp2.argument.msout.storagemanager.databitrate    = 16
apply_amp2.argument.msout.storagemanager.weightbitrate  = 12
apply_amp2.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_amp2.argument.msout.storagemanager.disttruncation = 1.5
apply_amp2.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

########## end of fourth or of the looped round of selfcal

########## start of looped round of selfcal
########## make image to check if we can stop the loop, or as new model

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile4.control.kind        = plugin
create_compressed_mapfile4.control.type        = compressMapfile
create_compressed_mapfile4.control.mapfile_in  = apply_amp2.output.mapfile
create_compressed_mapfile4.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile4.control.filename    = image4_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image42.control.type                    = wsclean
wsclean_image42.control.mapfiles_in             = [create_compressed_mapfile4.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image42.control.inputkeys               = [msfile,fitsmask]
wsclean_image42.argument.fits-mask              = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image42.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-join-channels,-save-source-list,msfile]
wsclean_image42.argument.channels-out           = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image42.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-save-source-list,msfile]
{% endif %}
wsclean_image42.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image42.argument.niter                  = 10000
wsclean_image42.argument.pol                    = I
wsclean_image42.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image42.argument.mgain                  = 0.8
wsclean_image42.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image42.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image42.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image42.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image42.argument.temp-dir               = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image42.argument.temp-dir               = {{ selfcal_local_dir }}
{% endif %}
wsclean_image42.argument.multiscale-shape       = gaussian
{% if not mscale_selfcal_do %}
wsclean_image42.argument.multiscale-scales      = 0,7
{% elif selfcal_multiscale_scales_pixel is not none %}
wsclean_image42.argument.multiscale-scales      = {{ selfcal_multiscale_scales_pixel }}
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image42.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image42.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image42.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image42.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image42.argument.auto-mask              = 2.0
{% else %}
wsclean_image42.argument.auto-mask              = 3.0
{% endif %}
wsclean_image42.argument.auto-threshold         = 0.5
wsclean_image42.argument.local-rms-window       = 50
wsclean_image42.argument.local-rms-method       = rms-with-min
wsclean_image42.argument.multiscale-scale-bias  = 0.5
wsclean_image42.argument.multiscale-gain        = 0.1

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map42.control.kind        = plugin
create_imagebase_map42.control.type        = trimMapfile
create_imagebase_map42.control.mapfile_in  = wsclean_image42.output.wsclean_image42-image.fits.mapfile
create_imagebase_map42.control.trim        = -
create_imagebase_map42.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map42.control.filename    = wsclean_image41_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile42.control.kind        = plugin
adjust_wsclean_mapfile42.control.type        = appendMapfile
adjust_wsclean_mapfile42.control.mapfile_in  = create_imagebase_map42.output.mapfile
adjust_wsclean_mapfile42.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile42.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile42.control.filename    = compare_image_input_new.mapfile

# copy the output image so that we can compare it later, length = 1
copy_image2.control.type       = copy_image
copy_image2.control.mapfile_in = adjust_wsclean_mapfile42.output.mapfile
copy_image2.control.inputkey   = image
copy_image2.argument.flags     = [image,loop_ampcal.output.counter,4]

# compare the current and the previous image to see if we can stop the loop, length = 1
check_image2.control.type        = compare_image_stats
check_image2.control.mapfiles_in = [adjust_wsclean_mapfile42.output.mapfile,copy_image2.output.previous_image.mapfile]
check_image2.control.inputkeys   = [image_new,image_prev]
check_image2.argument.flags      = [image_new,image_prev]

########## end of phase+amp selfcal loop
{% endblock selfcal_parameters %}
